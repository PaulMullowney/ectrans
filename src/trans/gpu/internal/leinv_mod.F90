#define ALIGN(I, A) (((I)+(A)-1)/(A)*(A))
! (C) Copyright 2000- ECMWF.
! (C) Copyright 2000- Meteo-France.
! (C) Copyright 2022- NVIDIA.
!
! This software is licensed under the terms of the Apache Licence Version 2.0
! which can be obtained at http://www.apache.org/licenses/LICENSE-2.0.
! In applying this licence, ECMWF does not waive the privileges and immunities
! granted to it by virtue of its status as an intergovernmental organisation
! nor does it submit to any jurisdiction.
!

MODULE LEINV_MOD
CONTAINS
SUBROUTINE LEINV(PIA,FOUBUF_IN)

!**** *LEINV* - Inverse Legendre transform.

!     Purpose.
!     --------
!        Inverse Legendre tranform of all variables(kernel).

!**   Interface.
!     ----------
!        CALL LEINV(...)

!        Explicit arguments :  KM - zonal wavenumber (input-c)
!        --------------------  KFC - number of fields to tranform (input-c)
!                              PIA - spectral fields
!                              for zonal wavenumber KM (input)

!        Implicit arguments :  None.
!        --------------------

!     Method.    use butterfly or dgemm
!     -------

!     Externals.
!     ----------

!     Reference.
!     ----------
!        ECMWF Research Department documentation of the IFS

!     Author.
!     -------
!      Nils Wedi + Mats Hamrud + George Modzynski
!
!     Modifications.
!     --------------
!        J.Hague : Oct 2012 DR_HOOK round calls to DGEMM:
!      F. Vana  05-Mar-2015  Support for single precision
!     ------------------------------------------------------------------

USE PARKIND_ECTRANS ,ONLY : JPIM     ,JPRB,  JPRBT, JPRD
USE YOMHOOK         ,ONLY : LHOOK,   DR_HOOK, JPHOOK
USE TPM_DIM         ,ONLY : R,R_NDGNH,R_NSMAX, R_NDGL
USE TPM_GEOMETRY    ,ONLY : G,G_NDGLU
USE TPM_TRANS       ,ONLY : REUSE_PTR
USE TPM_FIELDS      ,ONLY : ZAA,ZAS,ZAA0,ZAS0,KMLOC0
USE TPM_DISTR       ,ONLY : D,D_NUMP,D_MYMS, D_NPNTGTB1
USE TPM_GEN         ,ONLY : NOUT, LSYNC_TRANS
USE TPM_FLT
USE DEVICE_MOD
USE HICBLAS_MOD     ,ONLY : HIP_GEMM_BATCHED, HIP_DGEMM_BATCHED_OVERLOAD, &
 &                          HIP_DGEMM_GROUPED_OVERLOAD, HIP_SGEMM_GROUPED_OVERLOAD
USE MPL_MODULE      ,ONLY : MPL_BARRIER
#ifdef TRANS_SINGLE
#define HIP_GEMM HIP_SGEMM_GROUPED_OVERLOAD
#else
#define HIP_GEMM HIP_DGEMM_GROUPED_OVERLOAD
#endif
USE, INTRINSIC :: ISO_C_BINDING
USE IEEE_ARITHMETIC
USE OPENACC
USE TPM_STATS, ONLY : GSTATS => GSTATS_NVTX

IMPLICIT NONE


!     DUMMY ARGUMENTS
REAL(KIND=JPRB),    INTENT(IN)  :: PIA(:,:,:)
REAL(KIND=JPRB),    INTENT(OUT), ALLOCATABLE :: FOUBUF_IN(:)

!     LOCAL
INTEGER(KIND=JPIM)  :: KM
INTEGER(KIND=JPIM)  :: KMLOC
INTEGER(KIND=JPIM)  :: KIFC
INTEGER(KIND=JPIM)  :: IA, IS, ISL, J1, JGL, JK, J, IGLS, ISTAS, OFFSET1, OFFSET2, ISTATS
INTEGER(KIND=JPIM)  :: KFIELDS
INTEGER(KIND=JPIM)  :: KS(D_NUMP), NS(D_NUMP), AOFFSETS(D_NUMP), BOFFSETS(D_NUMP), COFFSETS(D_NUMP)

!     LOCAL
REAL(KIND=JPRBT), POINTER :: ZBASE(:), ZINP(:), ZOUTS(:), ZOUTA(:)
REAL(KIND=JPRD),  POINTER :: ZBASE0(:), ZINP0(:), ZOUTS0(:), ZOUTA0(:)
REAL(KIND=JPRBT) :: ZAOA, ZSOA

INTEGER(KIND=JPIM)  :: IOUT_STRIDES0, IOUT_STRIDES1
INTEGER(KIND=JPIM)  :: IIN_STRIDES0, IIN_STRIDES1
INTEGER(KIND=JPIM)  :: IOUT0_STRIDES0, IOUT0_STRIDES1
INTEGER(KIND=JPIM)  :: IIN0_STRIDES0, IIN0_STRIDES1
INTEGER(KIND=8)     :: ALLOC_SZ, ALLOC_POS


INTEGER(KIND=JPIM) :: ISTAT
INTEGER(KIND=JPIM) :: A = 8 !Alignment

REAL(KIND=JPHOOK) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK('LE_DGEMM',0,ZHOOK_HANDLE)
!     ------------------------------------------------------------------

KFIELDS = SIZE(PIA,1)

!*       1.       PERFORM LEGENDRE TRANFORM.
!                 --------------------------

!*       1.1      PREPARATIONS.

IIN_STRIDES0 = ALIGN(KFIELDS,A)
IIN_STRIDES1 = IIN_STRIDES0 * ALIGN(MAX((R%NTMAX+2)/2,(R%NTMAX+3)/2),A)
IOUT_STRIDES0 = ALIGN(KFIELDS,A)
IOUT_STRIDES1 = IOUT_STRIDES0 * ALIGN(R_NDGNH,A)
IIN0_STRIDES0 = ALIGN(KFIELDS/2,A)
IIN0_STRIDES1 = IIN0_STRIDES0 * ALIGN(MAX((R%NTMAX+2)/2,(R%NTMAX+3)/2),A)
IOUT0_STRIDES0 = ALIGN(KFIELDS/2,A)
IOUT0_STRIDES1 = IOUT0_STRIDES0 * ALIGN(R_NDGNH,A)

! Check if the reuse buffer is large enough
ALLOC_SZ = ALIGN(IIN_STRIDES1*D_NUMP,8)*SIZEOF(ZINP(1)) &
    +ALIGN(IOUT_STRIDES1*D_NUMP,8)*SIZEOF(ZOUTS(1)) &
    +ALIGN(IOUT_STRIDES1*D_NUMP,8)*SIZEOF(ZOUTA(1)) &
    +ALIGN(IIN0_STRIDES1,8)*SIZEOF(ZINP0(1)) &
    +ALIGN(IOUT0_STRIDES1,8)*SIZEOF(ZOUTS0(1)) &
    +ALIGN(IOUT0_STRIDES1,8)*SIZEOF(ZOUTA0(1))
IF (.NOT. ALLOCATED(REUSE_PTR)) THEN
  ALLOCATE(REUSE_PTR(ALLOC_SZ/SIZEOF(REUSE_PTR(1))))
#ifdef ACCGPU
  !$ACC ENTER DATA CREATE(REUSE_PTR)
#endif
ELSEIF (SIZEOF(REUSE_PTR) <= ALLOC_SZ) THEN
  ! and reallocate if needed
#ifdef ACCGPU
  !$ACC EXIT DATA DELETE(REUSE_PTR)
#endif
  DEALLOCATE(REUSE_PTR)
  ALLOCATE(REUSE_PTR(ALLOC_SZ/SIZEOF(REUSE_PTR(1))))
#ifdef ACCGPU
  !$ACC ENTER DATA CREATE(REUSE_PTR)
#endif
ENDIF

! Figure out which pointers to use
ALLOC_POS=1
CALL C_F_POINTER(C_LOC(REUSE_PTR(ALLOC_POS:)), ZBASE, &
    & [SIZEOF(REUSE_PTR(ALLOC_POS:))/SIZEOF(ZBASE(0))])

ZINP(1:) => ZBASE(ALLOC_POS:ALLOC_POS+IIN_STRIDES1*D_NUMP-1)
ALLOC_POS=ALLOC_POS+ALIGN(IIN_STRIDES1*D_NUMP,8)
ZOUTS(1:) => ZBASE(ALLOC_POS:ALLOC_POS+IOUT_STRIDES1*D_NUMP-1)
ALLOC_POS=ALLOC_POS+ALIGN(IOUT_STRIDES1*D_NUMP,8)
ZOUTA(1:) => ZBASE(ALLOC_POS:ALLOC_POS+IOUT_STRIDES1*D_NUMP-1)
ALLOC_POS=ALLOC_POS+ALIGN(IOUT_STRIDES1*D_NUMP,8)

! The BASE0 pointer points to the rest, but likely in a different type!
CALL C_F_POINTER(C_LOC(REUSE_PTR(ALLOC_POS:)), ZBASE0, &
    & [SIZEOF(REUSE_PTR(ALLOC_POS:))/SIZEOF(ZBASE0(0))])
ALLOC_POS=1
ZINP0(1:) => ZBASE0(ALLOC_POS:ALLOC_POS+IIN0_STRIDES1-1)
ALLOC_POS=ALLOC_POS+ALIGN(IIN0_STRIDES1,8)
ZOUTS0(1:) => ZBASE0(ALLOC_POS:ALLOC_POS+IOUT0_STRIDES1-1)
ALLOC_POS=ALLOC_POS+ALIGN(IOUT0_STRIDES1,8)
ZOUTA0(1:) => ZBASE0(ALLOC_POS:ALLOC_POS+IOUT0_STRIDES1-1)
ALLOC_POS=ALLOC_POS+ALIGN(IOUT0_STRIDES1,8)

#ifdef ACCGPU
!$ACC DATA  PRESENT(D_MYMS,G_NDGLU,D_NUMP,R_NDGNH,R_NSMAX) &
!$ACC&      PRESENT(ZINP,ZOUTS,ZOUTA,ZINP0,ZOUTS0,ZOUTA0) &
!$ACC&      PRESENT(ZAA,ZAS,PIA)  &
!$ACC&      PRESENT(D_MYMS,D_NPNTGTB1,G_NDGLU)
#endif
#ifdef OMPGPU
!$OMP TARGET DATA MAP(TO:D_MYMS,G_NDGLU,D_NUMP,R_NDGNH,R_NSMAX,ITDZBA, ITDZBS, ITDZCA, ITDZCS) &
!$OMP&      MAP(PRESENT,ALLOC:ZAA,ZAS,IZCST,ZIA,PSOA1,PAOA1,IZBS)
#endif

! TODO this doesn't make sense that we need it (???)
#ifdef ACCGPU
!$ACC KERNELS
#endif
ZINP(:) = 0
ZOUTS(:) = 0
ZOUTA(:) = 0
#ifdef ACCGPU
!$ACC END KERNELS
#endif

! READ 2:NSMAX+3

!IF KM=0 and NSMAX is 6:
!    IA=1
!    DO=1,6/2+1 ... 1..4
!       PIA_2=1+1+(J-1)*2 ...2+(0..3)*2 .... 2,4,6,8
!IF KM=0 and NSMAX is 7:
!    IA=2
!    DO=1,7/2+1 ... 1..4
!       PIA_2=2+1+(1..4-1)*2 ...3+(0..3)*2 .... 3,5,7,9

#ifdef OMPGPU
!$OMP TARGET TEAMS DISTRIBUTE PARALLEL DO COLLAPSE(2) PRIVATE(KM,ISKIP,ILA,ILS,IA) &
!$OMP&      SHARED(D_NUMP,R_NSMAX,KSTA,D_MYMS,IZBS,IF_FS_INV,ZIA) DEFAULT(NONE)
#endif
#ifdef ACCGPU
!$ACC PARALLEL LOOP COLLAPSE(2) PRIVATE(KM,IA,J) DEFAULT(NONE) &
!$ACC&    FIRSTPRIVATE(KFIELDS)
#endif
DO KMLOC=1,D_NUMP
  DO JK=1,KFIELDS
    KM =  D_MYMS(KMLOC)
    IA  = 1+MOD(R_NSMAX-KM+2,2)
    IF(KM /= 0)THEN
#ifdef ACCGPU
      !$ACC LOOP SEQ
#endif
      DO J=1,(R_NSMAX-KM+2)/2
        ZINP(JK+(J-1)*IIN_STRIDES0+(KMLOC-1)*IIN_STRIDES1)=PIA(JK,IA+1+(J-1)*2,KMLOC)
      ENDDO
    ELSEIF (MOD((JK-1),2) .EQ. 0) THEN
      ! every other field is sufficient because Im(KM=0) == 0
#ifdef ACCGPU
      !$ACC LOOP SEQ
#endif
      DO J=1,(R_NSMAX+2)/2
        ZINP0((JK-1)/2+1+(J-1)*IIN0_STRIDES0) = PIA(JK,IA+1+(J-1)*2,KMLOC)
      ENDDO
    ENDIF
  ENDDO
ENDDO

! operate on full arrays, where non-relavent entries have been set to zero
! Get C in transpose format to get better memory access patterns later
!C=A*B =>
! C^T=B^T*A^T

IF (LSYNC_TRANS) THEN
  CALL GSTATS(440,0)
  CALL MPL_BARRIER(CDSTRING='')
  CALL GSTATS(440,1)
ENDIF
CALL GSTATS(424,0)
! OVERLOADED FOR SINGLE AND DOUBLE PRECISION
#ifdef ACCGPU
!$ACC HOST_DATA USE_DEVICE(ZAA,ZINP,ZOUTA)
#endif
#ifdef OMPGPU
!$OMP TARGET DATA USE_DEVICE_PTR(ZAA,ZINP,ZOUTA)
#endif
DO KMLOC=1,D_NUMP
  KM = D_MYMS(KMLOC)
  KS(KMLOC) = (R%NSMAX-KM+2)/2
  NS(KMLOC) = G%NDGLU(KM)
  AOFFSETS(KMLOC) = IIN_STRIDES1*(KMLOC-1)
  BOFFSETS(KMLOC) = SIZE(ZAA,1)*SIZE(ZAA,2)*(KMLOC-1)
  COFFSETS(KMLOC) = IOUT_STRIDES1*(KMLOC-1)
ENDDO
IF(KMLOC0 > 0) THEN
  NS(KMLOC0) = 0
  KS(KMLOC0) = 0
ENDIF
CALL HIP_GEMM( &
  & 11, & ! unique identifier
  & 'N', 'T', &
  & KFIELDS, NS(:), KS(:), &
  & 1.0_JPRBT, &
  & ZINP, IIN_STRIDES0, AOFFSETS, &
  & ZAA, SIZE(ZAA,1), BOFFSETS, &
  & 0._JPRBT, &
  & ZOUTA, IOUT_STRIDES0, COFFSETS, &
  & D_NUMP, STREAM=ACC_ASYNC_SYNC)
#ifdef OMPGPU
!$OMP END TARGET DATA
#endif
#ifdef ACCGPU
!$ACC END HOST_DATA
#endif
ISTATS=DEVICE_SYNC()

IF (LSYNC_TRANS) THEN
  CALL GSTATS(444,0)
  CALL MPL_BARRIER(CDSTRING='')
  CALL GSTATS(444,1)
ENDIF
CALL GSTATS(424,1)

IF (KMLOC0 > 0) THEN
  print*,'computing m=0 in double precision'

#ifdef ACCGPU
  !$ACC HOST_DATA USE_DEVICE(ZAA0,ZINP0,ZOUTA0)
#endif
  CALL HIP_DGEMM_BATCHED_OVERLOAD( &
    & 'N', 'T', &
    & KFIELDS/2, G%NDGLU(0), (R%NSMAX+2)/2, &
    & 1.0_JPRD, &
    & ZINP0, IIN0_STRIDES0, 0, &
    & ZAA0, SIZE(ZAA0,1), 0, &
    & 0.0_JPRD, &
    & ZOUTA0, IOUT0_STRIDES0, 0, &
    & 1, STREAM=ACC_ASYNC_SYNC)
#ifdef ACCGPU
  !$ACC END HOST_DATA
#endif
ISTATS=DEVICE_SYNC()


ENDIF

! 2. +++++++++++++ symmetric
!IF KM=0 and NSMAX is 6:
!    IS=2
!    DO=1,4
!       PIA_2=2+1+(0..3)*2 ... 3+(0..3)*2 ... 3,5,7,9
!IF KM=0 and NSMAX is 7:
!    IS=1
!    DO=1,5
!       PIA_2=1+1+(1..5-1)*2 ...2+(0..4)*2 .... 2,4,6,8,10


#ifdef OMPGPU
!$OMP TARGET TEAMS DISTRIBUTE PARALLEL DO COLLAPSE(2) PRIVATE(KM,ISKIP,ILS,IS) &
!$OMP&      SHARED(D_NUMP,R_NSMAX,KFC,KSTA,D_MYMS,IZBS,ITDZBS,ILDZBS,ZIA) DEFAULT(NONE)
#endif
#ifdef ACCGPU
!$ACC PARALLEL LOOP COLLAPSE(2) PRIVATE(KM,IS,J) DEFAULT(NONE) &
!$ACC&    FIRSTPRIVATE(KFIELDS)
#endif
DO KMLOC=1,D_NUMP
  DO JK=1,KFIELDS
    KM =  D_MYMS(KMLOC)
    IS = 1+MOD(R_NSMAX-KM+1,2)
    IF(KM /= 0)THEN
#ifdef ACCGPU
      !$ACC LOOP SEQ
#endif
      DO J=1,(R_NSMAX-KM+3)/2
        ZINP(JK+(J-1)*IIN_STRIDES0+(KMLOC-1)*IIN_STRIDES1)=PIA(JK,IS+1+(J-1)*2,KMLOC)
      ENDDO
    ELSEIF (MOD((JK-1),2) == 0) THEN
#ifdef ACCGPU
      !$ACC LOOP SEQ
#endif
      DO J=1,(R_NSMAX+3)/2
        ZINP0((JK-1)/2+1+(J-1)*IIN0_STRIDES0) = PIA(JK,IS+1+(J-1)*2,KMLOC)
      ENDDO
    ENDIF
  ENDDO
ENDDO


!C=A*B =>
! C^T=B^T*A^T

IF (LSYNC_TRANS) THEN
  CALL GSTATS(440,0)
  CALL MPL_BARRIER(CDSTRING='')
  CALL GSTATS(440,1)
ENDIF
CALL GSTATS(424,0)
#ifdef OMPGPU
!$OMP TARGET DATA USE_DEVICE_PTR(ZAS,ZINP,ZOUTS)
#endif
#ifdef ACCGPU
!$ACC HOST_DATA USE_DEVICE(ZAS,ZINP,ZOUTS)
#endif
DO KMLOC=1,D_NUMP
  KM = D_MYMS(KMLOC)
  KS(KMLOC) = (R%NSMAX-KM+3)/2
  NS(KMLOC) = G%NDGLU(KM)
  AOFFSETS(KMLOC) = IIN_STRIDES1*(KMLOC-1)
  BOFFSETS(KMLOC) = SIZE(ZAS,1)*SIZE(ZAS,2)*(KMLOC-1)
  COFFSETS(KMLOC) = IOUT_STRIDES1*(KMLOC-1)
ENDDO
IF(KMLOC0 > 0) THEN
  NS(KMLOC0) = 0
  KS(KMLOC0) = 0
ENDIF
CALL HIP_GEMM( &
  & 12, & ! unique identifier
  & 'N', 'T', &
  & KFIELDS, NS(:), KS(:), &
  & 1.0_JPRBT, &
  & ZINP, IIN_STRIDES0, AOFFSETS, &
  & ZAS, SIZE(ZAS,1), BOFFSETS, &
  & 0.0_JPRBT, &
  & ZOUTS, IOUT_STRIDES0, COFFSETS, &
  & D_NUMP, STREAM=ACC_ASYNC_SYNC)
#ifdef OMPGPU
!$OMP END TARGET DATA
#endif
#ifdef ACCGPU
!$ACC END HOST_DATA
#endif
ISTATS=DEVICE_SYNC()
IF (LSYNC_TRANS) THEN
  CALL GSTATS(444,0)
  CALL MPL_BARRIER(CDSTRING='')
  CALL GSTATS(444,1)
ENDIF
CALL GSTATS(424,1)

IF (KMLOC0 > 0) THEN
#ifdef ACCGPU
  !$ACC HOST_DATA USE_DEVICE(ZAS0,ZINP0,ZOUTS0)
#endif
  CALL HIP_DGEMM_BATCHED_OVERLOAD( &
    & 'N', 'T', &
    & KFIELDS/2, G%NDGLU(0), (R%NSMAX+3)/2, &
    & 1.0_JPRD, &
    & ZINP0, IIN0_STRIDES0, 0, &
    & ZAS0, SIZE(ZAS0,1), 0, &
    & 0.0_JPRD, &
    & ZOUTS0, IOUT0_STRIDES0, 0, &
    & 1, STREAM=ACC_ASYNC_SYNC)
#ifdef ACCGPU
  !$ACC END HOST_DATA
#endif
  ISTATS=DEVICE_SYNC()

ENDIF

ALLOCATE(FOUBUF_IN(D%NLENGT1B*KFIELDS))
#ifdef ACCGPU
!$ACC ENTER DATA CREATE(FOUBUF_IN)
#endif

IF (KMLOC0 > 0) THEN
#ifdef ACCGPU
  !$ACC PARALLEL LOOP COLLAPSE(2) DEFAULT(NONE)
#endif
  DO JGL=1,G_NDGLU(0)
    DO JK=1,KFIELDS,2
      ZOUTA((JK-1)/2+1+(JGL-1)*IOUT_STRIDES0+(KMLOC0-1)*IOUT_STRIDES1) &
        & = ZOUTA0((JK-1)/2+1+(JGL-1)*IOUT0_STRIDES0)
      ZOUTS((JK-1)/2+1+(JGL-1)*IOUT_STRIDES0+(KMLOC0-1)*IOUT_STRIDES1) &
        & = ZOUTS0((JK-1)/2+1+(JGL-1)*IOUT0_STRIDES0)
    ENDDO
  ENDDO

ENDIF
#ifdef ACCGPU
!$ACC DATA PRESENT(FOUBUF_IN)
#endif

#ifdef OMPGPU
!$OMP TARGET TEAMS DISTRIBUTE PARALLEL DO COLLAPSE(2) PRIVATE(KM,ISKIP,ISL) &
!$OMP&      SHARED(D_NUMP,R_NDGNH,KFC,D_MYMS,G_NDGLU,PSOA1,IZCST,ITDZCS,ILDZCS) DEFAULT(NONE)
#endif
#ifdef ACCGPU
!$ACC PARALLEL LOOP COLLAPSE(3) PRIVATE(KM,ISL,IGLS,OFFSET1,OFFSET2,ZAOA,ZSOA) DEFAULT(NONE) &
!$ACC&    FIRSTPRIVATE(KFIELDS) PRESENT(R_NDGL)
#endif
DO KMLOC=1,D_NUMP
  DO JGL=1,R_NDGNH
    DO JK=1,KFIELDS
      KM = D_MYMS(KMLOC)
      ISL = R_NDGNH-G_NDGLU(KM)+1
      IF (JGL >= ISL) THEN
        !(DO JGL=ISL,R_NDGNH)
        IGLS = R_NDGL+1-JGL
        OFFSET1 = D_NPNTGTB1(KMLOC,JGL )*KFIELDS
        OFFSET2 = D_NPNTGTB1(KMLOC,IGLS)*KFIELDS

        IF(KM /= 0) THEN
          ZSOA = ZOUTS(JK+(JGL-ISL)*IOUT_STRIDES0+(KMLOC-1)*IOUT_STRIDES1)
          ZAOA = ZOUTA(JK+(JGL-ISL)*IOUT_STRIDES0+(KMLOC-1)*IOUT_STRIDES1)
        ELSEIF (MOD((JK-1),2) .EQ. 0) THEN
          ZSOA = ZOUTS((JK-1)/2+1+(JGL-ISL)*IOUT_STRIDES0+(KMLOC-1)*IOUT_STRIDES1)
          ZAOA = ZOUTA((JK-1)/2+1+(JGL-ISL)*IOUT_STRIDES0+(KMLOC-1)*IOUT_STRIDES1)
        ELSE
          ! Imaginary values of KM=0 is zero, though I don't think we care
          ZSOA = 0_JPRBT
          ZAOA = 0_JPRBT
        ENDIF

        FOUBUF_IN(OFFSET1+JK) = ZAOA+ZSOA
        FOUBUF_IN(OFFSET2+JK) = ZSOA-ZAOA
      ENDIF

    ENDDO
  ENDDO
ENDDO
#ifdef OMPGPU
#endif
#ifdef ACCGPU
!$ACC END DATA
!$ACC END DATA
#endif


IF (LHOOK) CALL DR_HOOK('LE_DGEMM',1,ZHOOK_HANDLE)
!     ------------------------------------------------------------------

END SUBROUTINE LEINV
END MODULE LEINV_MOD
